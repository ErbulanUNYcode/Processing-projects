float W = 3.1, W1 = 2.7, a, R, Wr, X, X1, Y, Y1, x, x1, y, y1, c, p, k, x_z, y_z, sz;
boolean s=true;
/*
W, W1-частота волн
a-угол
R-радиус
Wr-высота волн
X, X1, Y, Y1-координатные поворачиватели(не спрашивать зачем так назвал)
x, y и x1, y1-начальные и конечные координаты для каждого line(а который начальный? обе, работают очерёдно)
c-отвечает за плавное смещение цвета
p-плавное движение волны, так сказать вперед 
k-должен был отвечать за плавное исчезновение начала и конца волновой ленты
x_z, y_z-используется для смещения координат ровно в центр в зависимости от разрешения экрана
sz-сокращённо size
s-булевое для ограничения однократных процессов в цыкле
*/
void setup(){
  size(600,600);
  background(0);
  fill(0,20);
}

void draw(){
  if(s){
    s=false;
    x_z = float(width)/2;
    y_z = float(height)/2;
    sz = x_z/500;
    if(x_z<y_z){
      R=x_z/2;
    }else{
      R=y_z/2;
    }
    Wr=R;
  }
  noStroke();
  rect(0,0,width, height);
  x=sin(a+X)*(sin(a*W)*Wr+R)*sz;
  y=cos(a+X)*(cos(a*W)*Wr+R)*sz;
  X=X+0.003;
  X1=X1+0.006;
  Y=Y+0.004;
  Y1=Y1+0.005;
  c+=0.05;
  p=p+0.007;
  
  for(a=p;a-p<8;a=a+0.04){
    x1=sin(a+X1)*(sin(a*W1)*Wr+R*(a-p)/4)*sz;
    y1=cos(a+Y1)*(cos(a*W1)*Wr+R*(a-p)/4)*sz;
    if(a-p<1){
      k=(-cos((a-p)*PI));
    }else if(a-p>7){
      k=(cos((a-p-7)*PI));
    }else{
      k=1;
    }
    stroke((sin(a+c)+1)/2*255,(sin(a+c+PI*2/3)+1)/2*255,(sin(a+c+PI*4/3)+1)/2*255,(k+1)/2*255);
    line(x+x_z,y+y_z,x1+x_z,y1+y_z);
    x=sin(a+0.01+X)*(sin((a+0.01)*W)*Wr+R/(a-p)*2)*sz;
    y=cos(a+0.01+Y)*(cos((a+0.01)*W)*Wr+R/(a-p)*2)*sz;
    stroke((sin(a+0.01+c)+1)/2*255,(sin(a+0.01+c+120)+1)/2*255,(sin(a+0.01+c+240)+1)/2*255,(k+1)/2*255);
    line(x1+x_z,y1+y_z,x+x_z,y+y_z);
  }
} 
  
